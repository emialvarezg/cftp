# -*- coding: utf-8 -*-
"""cftp ising.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d4l4EElJPDFP8LXI63CYfnrRLq3jBj-8
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import random

G= nx.grid_graph(dim=(100,100))

def S(s,v,G):
  vec = list(G.neighbors(v))
  return sum([s[i] for i in vec])

s0 =dict(nx.nodes(G))
for i in list(nx.nodes(G)):
  s0[i]=-1

s1 =dict(nx.nodes(G))
for i in list(nx.nodes(G)):
  s1[i]=1

n=200000
b=1/500
s0 =dict(nx.nodes(G))
for i in list(nx.nodes(G)):
  s0[i]=-1

s1 =dict(nx.nodes(G))
for i in list(nx.nodes(G)):
  s1[i]=1
for i in range(n):
  v = random.choices(list(nx.nodes(G)))
  p0 = (1+np.tanh(b*S(s0,v[0],G)))/2
  u= np.random.uniform()
  if u<p0:
    s0[v[0]]=1
  else:
    s0[v[0]]=-1

  p1 = (1+np.tanh(b*S(s1,v[0],G)))/2
  if u<p1:
    s1[v[0]]=1
  else:
    s1[v[0]]=-1

s0==s1

for i in list(nx.nodes(G)):
  if s0[i] == 1:
    plt.scatter(i[0],i[1],color='cornflowerblue',marker='s')
  else:
    plt.scatter(i[0],i[1],color='lightpink',marker='s')

ax1=[]
ay1=[]
#rx1=[]
#ry1=[]
for i in list(nx.nodes(G)):
  if s0[i] == 1:
    ax1.append(i[0])
    ay1.append(i[1])
  #else:
   # rx.append(i[0])
    #ry.append(i[1])


#plt.scatter(rx,ry,marker='s',color='lightpink')
plt.scatter(ax1,ay1,marker='s',color='k')

G2= nx.grid_graph(dim=(65,90))
n2=60000
b2=1/600
s02 =dict(nx.nodes(G2))
for i in list(nx.nodes(G2)):
  s02[i]=-1

s12 =dict(nx.nodes(G2))
for i in list(nx.nodes(G2)):
  s12[i]=1
for i in range(n2):
  v2 = random.choices(list(nx.nodes(G2)))
  p02 = (1+np.tanh(b2*S(s02,v2[0],G2)))/2
  u2= np.random.uniform()
  if u2<p02:
    s02[v2[0]]=1
  else:
    s02[v2[0]]=-1

  p12 = (1+np.tanh(b2*S(s12,v2[0],G2)))/2
  if u2<p12:
    s12[v2[0]]=1
  else:
    s12[v2[0]]=-1

s12==s02

ax=[]
ay=[]
rx=[]
ry=[]
for i in list(nx.nodes(G2)):
  if s02[i] == 1:
    ax.append(i[0])
    ay.append(i[1])
  else:
    rx.append(i[0])
    ry.append(i[1])


plt.scatter(rx,ry,marker='.',color='crimson')
plt.scatter(ax,ay,marker='.',color='cornflowerblue')
plt.tick_params(axis='x', which='both', bottom=False,
                top=False, labelbottom=False)

# Selecting the axis-Y making the right and left axes False
plt.tick_params(axis='y', which='both', right=False,
                left=False, labelleft=False)

# Iterating over all the axes in the figure
# and make the Spines Visibility as False
for pos in ['right', 'top', 'bottom', 'left']:
    plt.gca().spines[pos].set_visible(False)


plt.savefig("ising 90x65 1.eps", format='eps')

G3= nx.grid_graph(dim=(38,52))
n3=50000
b3=1/100
s03 =dict(nx.nodes(G3))
for i in list(nx.nodes(G3)):
  s03[i]=-1

s13 =dict(nx.nodes(G3))
for i in list(nx.nodes(G3)):
  s13[i]=1
for i in range(n3):
  v3 = random.choices(list(nx.nodes(G3)))
  p03 = (1+np.tanh(b3*S(s03,v3[0],G3)))/2
  u3= np.random.uniform()
  if u3<p03:
    s03[v3[0]]=1
  else:
    s03[v3[0]]=-1

  p13 = (1+np.tanh(b3*S(s13,v3[0],G3)))/2
  if u3<p13:
    s13[v3[0]]=1
  else:
    s13[v3[0]]=-1

bool(s13==s03)

ax3=[]
ay3=[]
rx3=[]
ry3=[]
for i in list(nx.nodes(G3)):
  if s03[i] == 1:
    ax3.append(i[0])
    ay3.append(i[1])
  else:
    rx3.append(i[0])
    ry3.append(i[1])


#plt.scatter(rx,ry,marker='.',color='lightpink')
#plt.scatter(ax,ay,marker='.',color='cornflowerblue')
plt.scatter(rx3,ry3,marker='s',color='cornflowerblue')
plt.scatter(ax3,ay3,marker='s',color='crimson')


plt.tick_params(axis='x', which='both', bottom=False,
                top=False, labelbottom=False)

# Selecting the axis-Y making the right and left axes False
plt.tick_params(axis='y', which='both', right=False,
                left=False, labelleft=False)

# Iterating over all the axes in the figure
# and make the Spines Visibility as False
for pos in ['right', 'top', 'bottom', 'left']:
    plt.gca().spines[pos].set_visible(False)

plt.savefig("ising 52x38  pres 2.eps", format='eps')





ex = 0
G3= nx.grid_graph(dim=(38,52))
n3=50000
b3=1/100
for k in range(1000):
  s03 =dict(nx.nodes(G3))
  for i in list(nx.nodes(G3)):
    s03[i]=-1

  s13 =dict(nx.nodes(G3))
  for i in list(nx.nodes(G3)):
    s13[i]=1
  for i in range(n3):
    v3 = random.choices(list(nx.nodes(G3)))
    p03 = (1+np.tanh(b3*S(s03,v3[0],G3)))/2
    u3= np.random.uniform()
    if u3<p03:
      s03[v3[0]]=1
    else:
      s03[v3[0]]=-1

    p13 = (1+np.tanh(b3*S(s13,v3[0],G3)))/2
    if u3<p13:
      s13[v3[0]]=1
    else:
      s13[v3[0]]=-1

  if s13==s03:
      ex+=1

ex