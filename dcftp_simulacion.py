# -*- coding: utf-8 -*-
"""dcftp simulacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_yIUf3IiwQYFQ7k5TAzPdsqyTiyfut1c
"""

import numpy as np
import matplotlib.pyplot as plt

#función para generar una variable aleatoria geométrica de parámetro p
def geo(p):
  X=0
  while np.random.uniform()>= p:
    X+=1
  return X+1

#transición de la cadena X
def phi(x,u,M,b):
  M1 = u**(1/b)*(1+M)
  if x!=M:
    u1 = (u-((1+x)/(1+M))**b)/(1-((1+x)/(1+M))**b)
  else:
    u1 =1

  return M1*bool(M1 <= (1+x).real) + u1**(1/b)*(1+x)*bool(M1 > (1+x).real)

#beta
b=10

#número de pasos
n=60

#punto inicial
x0 = (1+(2/3)**(1/b))/(1-(2/3)**(1/b))
D0 = x0 - 1 + geo(1/2)

#simulamos hacia atrás la caminata que domina
ca = [D0]
for i in range(n):
  A = np.random.uniform()
  D = D0 + bool(A > 2/3) - bool (A <= 2/3 and D0 >= x0)
  ca.append(D)
  D0 = D

muestras = []
#condiciones inciales
M0 = ca[-1] #punto en donde terminó la cadena D
m0 = 0

#simulamos las uniformes para la transición acopladas a coincidir con las transiciones hacia adelante de D
unif = []
for j in range(len(ca)-1):
  if ca[j] <= ca[j+1]:
    unif.append(np.random.uniform(0,2/3))
  else:
    unif.append(np.random.uniform(2/3,1))

#simulamos las caminatas acopladas
cam=[m0]
caM=[M0]
for i in range(n):
  m = phi(m0,unif[i],M0,b)
  M = phi(M0, unif[i],M0,b)

  cam.append(m)
  caM.append(M)
  m0 = m
  M0 = M

#si hay coalescencia regresamos el valor
if cam[-1]==caM[-1]:
  muestras.append(cam[-1].real)

#gráfica de las trayectorias
t = [i for i in range(len(ca))]

#invertimos la caminata que domina para graficar
revca = ca[::-1]

#caminata que domina
plt.scatter(t,revca,color='magenta',marker='.')
#caminata empezando en el máximo
plt.scatter(t,caM,marker='*',color='midnightblue')
#caminata empezando en el mínimo
plt.scatter(t,cam,marker='.',color='cornflowerblue')

#plt.savefig("cftp pres d 3.eps", format='eps')

#otro ejemplo (mismo código)
b2=0.8
n2=20
x02 = (1+(2/3)**(1/b2))/(1-(2/3)**(1/b2))
D02 = x02 - 1 + geo(1/2)

#caminata que domina
ca2 = [D02]
for i in range(n2):
  A2 = np.random.uniform()
  D2 = D02 + bool(A2 > 2/3) - bool (A2 <= 2/3 and D02 >= x02)
  ca2.append(D2)
  D02 = D2

M02 = ca2[-1]
m02 = 0
#uniformes condicionadas
unif2 = []
for j in range(len(ca2)-1):
  if ca2[j] <= ca2[j+1]:
    unif2.append(np.random.uniform(0,2/3))
  else:
    unif2.append(np.random.uniform(2/3,1))
cam2=[m02]
caM2=[M02]
for i in range(n2):
  m2 = phi(m02,unif2[i],M02,b2)
  M2 = phi(M02, unif2[i],M02,b2)

  cam2.append(m2)
  caM2.append(M2)
  m02 = m2
  M02 = M2

print(cam2[-1]==cam2[-1])

t2 = [i for i in range(len(ca2))]

#plt.scatter(t,ca)
#plt.scatter(t,caM)
plt.scatter(t2,cam2,alpha=0.8,marker='.',color='cornflowerblue')
plt.scatter(t2,caM2,alpha=0.4,marker='*',color='magenta')

#en este bloque generamos 1000 muestras para hacer un histograma
b=10
n=120
x0 = (1+(2/3)**(1/b))/(1-(2/3)**(1/b))
muestras=[]
for i in range(10000):
  D0 = x0 - 1 + geo(1/2)
  ca = [D0]
  for i in range(n):
    A = np.random.uniform()
    D = D0 + bool(A > 2/3) - bool (A <= 2/3 and D0 >= x0)
    ca.append(D)
    D0 = D

  M0 = ca[-1]
  m0 = 0
  unif = []
  for j in range(len(ca)-1):
    if ca[j] <= ca[j+1]:
      unif.append(np.random.uniform(0,2/3))
    else:
      unif.append(np.random.uniform(2/3,1))
  cam=[m0]
  caM=[M0]
  for i in range(n):
    m = phi(m0,unif[i],M0,b)
    M = phi(M0, unif[i],M0,b)

    cam.append(m)
    caM.append(M)
    m0 = m
    M0 = M

  if cam[-1]==caM[-1]:
    muestras.append(cam[-1].real)

len(muestras)

#histograma
plt.hist(muestras,bins=30,density=True,color='cornflowerblue')
plt.title('β = 10')
#plt.savefig("dcftp hist b05.eps", format='eps')

#cota inferior para el número de pasos necesarios en función de beta
def cota(b,e):
  x = (1+(2/3)**(1/b))/(1-(2/3)**(1/b))
  return np.log(4*(e**(-2))*b*(x+1))*(b+1) + 1

e = 0.05
b = np.linspace(0.01,1.5, 200)
c = [cota(j,e) for j in b ]

#gráfica de beta contra el número de pasos necesarios
plt.plot(b,c)
plt.xlabel('β')
plt.ylabel('t')
plt.savefig("t para beta 1.eps", format='eps')